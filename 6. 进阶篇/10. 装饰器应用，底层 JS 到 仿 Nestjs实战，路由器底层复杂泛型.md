# 装饰器应用，底层 JS 到 仿 Nestjs实战，路由器底层复杂泛型

## 掌握装饰器对前端有什么好处？

装饰器是前端了不起的技术革命，弥补了只有后端语言才有 AOP【类似装饰器】的短板，学习装饰器好处有:

1. 较大提升前端架构思维和前端架构能力，装饰器底层蕴含的拦截器思想在 Java Spring, Nestjs框架，python 各种后端语言中都有广泛的应用，而拦截器展示的就是一种架构思维，通过学习装饰器能扩大技术视野，是作为一名前端架构师以及更高职位必会技能。

2. Nestjs 等相对新型的 Nodejs 框架大量运用了 TS 装饰器, 例如： @Controller @Service  @Get @Post

3. 在面试中，如果告诉面试官，你精通装饰器，这也能成为你的大加分项，因为公司更需架构思维能力强的前端工程师，因为具有架构思维的前端开发人员在大中项目中一定能写出扩展性更好的代码。

## 【装饰器概述】装饰器定义，分类，要解决的问题

**1  装饰器定义：**

装饰器就是一个方法或者叫函数，可以注入【写到】到类、方法、属性、参数，对象上，扩展其功能。

**高阶组件本质上也采用了装饰器的思想。**

**2 装饰器要解决的问题：**

装饰器就是解决在不修改原来类、方法，属性，参数的时候为其添加额外的功能。比如：为整个项目的所有业务类【假如50个类】的所有方法【假如6个方法】都增加日志信息，如果一个一个的增加，那要增加300次日志调用语句，假如日后日志文件格式发生了改变，也还需要修改300次。 如果有了装饰器，只需要修改一次就可以。这个属于项目中的通用功能，大家了解下即可，后面我们仿 Nestjs 实战 时对装饰器的这个特性会有很深的体会。

在 Nestjs 中 装饰器可以解决依赖注入的问题，而依赖注入是 Java 等后端语言拥有的非常优秀的编程思想，

有了依赖注入，能大大降低项目的耦合度，大大提升项目的可扩展性。

使用和创建分离是依赖注入的核心思想。

**3. 装饰器分类：**

常见的装饰器：类装饰器、属性装饰器、方法装饰器、参数装饰器，元数据装饰器。

**4. 元数据装饰器初步理解：**

元数据装饰器：在定义类或者类方法或者对象的时候，可以设置一些元数据，我们可以获取到在类与类方法上添加的元数据，需要引入 `reflect-metadata` 第三方库  采用 `@Reflect.metadata` 来实现。元数据指的是描述东西时用的数据，例如：Reflect.metadata("importinfo", "疫情期间用公筷,戴口罩")。

**5. 装饰器两种写法：**

**写法1：**让调用时（使用时） 不传递参数的装饰器

**写法2**：装饰器工厂【让调用时 可以传递参数的装饰器】。

## 【类装饰器】类装饰器实现

**1.  环境搭建**

1. 安装 concurrently 支持合并执行，同时运行多个 script 命令：

   ```js
   cnpm  i  concurrently -S 或 yarn add  concurrently -S
   cnpm  i  nodemon -S 或 yarn add  nodemon -S
   ```

2. tsconfig.json 文件修改如下：

   ```js
    --编译输入输出目录
        "outDir":"./dist",
        "rootDir":"./src",
    -- 消除装饰器警告
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
   ```

3. 配置 package.json 文件脚本信息

```js
   "scripts": {

    "dev:build": "tsc -w",

     --监控 dist/teaching 目录中的 js 文件，变化时执行 node 命令
    "dev:start":"nodemon --watch dist/teaching js --exec  node ./dist/teaching/1ClassDecorator.js",

     --合并启动
    "start":  "concurrently npm:dev:*"

     --命令解决 typescript 编译装饰器类时出现的 bug
     "tsc":"tsc src/teaching/1ClassDecorator.ts  --target ES5 -w --experimentalDecorators"

     --后面会用到，先配置上
    "ctrl":"ts-node src/controller/HomeController.ts",
    "beginapp": "nodemon --watch src/ -e ts --exec ts-node ./src/expressapp.ts",
    }
```

4.   类装饰器两种实现 [带参数和不带参数]

```js
   // 不带参数的类装饰器案例：
   function FirstClassDecorator(targetClass: any) {
       console.log(targetClass.prototype.constructor.name + "信息");
       Object.keys(targetClass.prototype).forEach((methodname) => {
         console.log("方法", methodname)
         let dataprop = Object.getOwnPropertyDescriptor(targetClass.prototype, methodname)
         console.log("方法数据属性:", dataprop);
       })
     }
   }

   @FirstClassDecorator
   class CustomerService {
     name: string = "下单"
     constructor() {

     }
     buy() {
       console.log(this.name + "购买");
     }
     placeOrder() {//下单
       console.log(this.name + "下单购买");
     }
   }

   // 带参数类装饰器案例
   function FirstClassDecorator(classinfo: string) {
     return function (targetClass: any) {
       console.log(targetClass.prototype.constructor.name + "信息");
       Object.keys(targetClass.prototype).forEach((methodname) => {
         console.log("方法", methodname)
         let dataprop = Object.getOwnPropertyDescriptor(targetClass.prototype, methodname)
         console.log("方法数据属性:", dataprop);
       })
     }
   }
```

## 【类装饰器底层源码】逐行深剖底层 JS 源码

```js
"use strict";
// 1. 底层JS 组合装饰器和目标类 __decorate函数
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
  // argsnum 参数个数
  var argsnum = arguments.length;
  // targetinfo 被装饰器修饰的目标【本案例为类】
  // argsnum=2 装饰器修饰的是类或者构造器参数，targetinfo=target[类名]
  // argsnum=4 装饰器修饰的是方法【第四个参数desc等于null] targetinfo=该方法的数据属性【desc = Object.getOwnPropertyDescriptor(target, key) 】
  // argsnum=3 装饰器修饰的是方法参数或者属性,targetinfo=undefined
  var targetinfo = argsnum < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;//S100
  // decorator保存装饰器数组元素
  var decorator;
  // 元数据信息,支持reflect-metadata元数据
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {
    targetinfo = Reflect.decorate(decorators, target, key, desc);
  } else
    //  装饰器循环,倒着循环,说明同一个目标上有多个装饰器，执行顺序是倒着执行
    for (var i = decorators.length - 1; i >= 0; i--) {
      if (decorator = decorators[i]) {
        // 如果参数小于3【decorator为类装饰器或者构造器参数装饰器】执行decorator(targetinfo)直接执行decorator装饰器，并传递目标targetinfo，这里是类
        // 如果参数大于3【decorator为方法装饰器】 直接执行 decorator(target, key, targetinfo)
        // 如果参数等于3 【decorator为方法参数装饰器或者属性装饰器】 直接执行decorator(target, key)
        // targetinfo最终为各个装饰器执行后的返回值,但如果没有返回值,直接返回第S100行的targetinfo
        targetinfo = (argsnum < 3 ? decorator(targetinfo) : argsnum > 3 ?
          decorator(target, key, targetinfo) : decorator(target, key)) || targetinfo;
        console.log("targetinforesult:", targetinfo)
      }
    }
  return argsnum > 3 && targetinfo && Object.defineProperty(target, key, targetinfo), targetinfo;
}
// 底层JS 组合装饰器和目标类 __decorate函数结束

// 2. 传递参数的类装饰器
function FirstClassDecorator (classinfo) {
  return function (targetClass) {
    console.log(targetClass.prototype.constructor.name + "信息");
    Object.keys(targetClass.prototype).forEach(function (methodname) {
      console.log("方法", methodname);
      var dataprop = Object.getOwnPropertyDescriptor(targetClass.prototype, methodname);
      console.log("方法数据属性:", dataprop);
    });
    //return 3
  };
}

// 3.目标类
var Test = /** @class */ (function () {
  function Test () {
    this.name = "下单";
  }
  Test.prototype.buy = function () {
    console.log(this.name + "购买");
  };
  Test.prototype.placeOrder = function () {
    console.log(this.name + "下单购买");
  };
  Test =LoggerSonClass
  return Test;
}());

```

## 【泛型工厂类继承装饰器】 泛型工厂类继承装饰器实现和意义

1. 泛型工厂类继承装饰器实现
2. 泛型工厂类继承装饰器意义

```js
// 1. 泛型工厂类继承装饰器
function ClassFunctionExtends<T extends { new (...args: any[]): any }> (mytargetClass: T) {
  console.log("mytargetClass", mytargetClass);
  class SonClass extends mytargetClass {
    constructor(...args: any[]) {
      super(args);
      console.log("SonClass执行结束");
    }
    commonMethod() {
      //console.log("this:", this)
      console.log("name:", this.name)
    }
  }
  return SonClass
}

// 2. 目标类
@ClassFunctionExtends
class Test {
  name!: string;
  age!: number
  // 1.先执行原来构造函数
  constructor(name: string) {
    this.name = name;

  }
  eat() {
    console.log(this.name, "吃饭");
  }
}
//let SonClass = ClassFunctionExtends<typeof Test>(Test)
let SonClass = ClassFunctionExtends(Test)
let SonClassObj=new SonClass("wangwu");
```

## 【泛型工厂类继承装饰器底层源码】逐行深剖+优化底层 JS 源码

底层 JS 组合装饰器和目标类 __decorate 函数

```js
//  1.  拷贝前面继承源码代码
let __extends = (function (Son, Parent) {

  function getStaticExtendsWithForIn (Son, Parent) {
    for (let key in Parent) {
      if (Object.prototype.hasOwnProperty.call(Parent, key)) {
        Son[key] = Parent[key]
      }
    }
  }

  function getStaticExtendsWithObjectkeys (Son, Parent) {
    Object.keys(Parent).forEach((key) => {
      Son[key] = Parent[key]
    })
  }

  function getStaticExtendsWithProto (Son, Parent) {
    Son.__proto__ = Parent;
  }

  let MyextendStatics = function (Son, Parent) {
    let MyextendStatics = Object.setPrototypeOf || getStaticExtendsWithForIn ||
      getStaticExtendsWithObjectkeys || getStaticExtendsWithProto
    return MyextendStatics(Son, Parent)
  }

  return function (Son, Parent) {
    MyextendStatics(Son, Parent)
    function Middle () {
      this.constructor = Son;
    }
    if (Parent) {//如果不为空 如果父类存在
      Middle.prototype = Parent.prototype;
      Son.prototype = new Middle()
    } else {// 如果父类不存在
      Son.prototype = Object.create(null)
    }
    console.log("Object.create(null):", Object.create(null));
  }
}())

// 2. 底层JS 组合装饰器和目标类 __decorate 函数
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
  // argsnum 参数个数
  var argsnum = arguments.length;
  // targetinfo 被装饰器修饰的目标【类或属性或方法或方法参数，本案例为类】
  // argsnum=2 装饰器修饰的是类或者构造器参数，targetinfo=target[类名]
  // argsnum=4 装饰器修饰的是方法【第四个参数desc等于null] targetinfo=该方法的数据属性【desc = Object.getOwnPropertyDescriptor(target, key) 】
  // argsnum=3 装饰器修饰的是方法参数或者属性,targetinfo=undefined
  var targetinfo = argsnum < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;//S100
  // decorator保存装饰器数组元素
  var decorator;
  // 元数据信息,支持reflect-metadata元数据
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {
    targetinfo = Reflect.decorate(decorators, target, key, desc);
  } else
    //  装饰器循环,倒着循环,说明同一个目标上有多个装饰器，执行顺序是倒着执行
    for (var i = decorators.length - 1; i >= 0; i--) {
      if (decorator = decorators[i]) {
        // 如果参数小于3【decorator为类装饰器或者构造器参数装饰器】执行decorator(targetinfo)直接执行decorator装饰器，并传递目标targetinfo，这里是类
        // 如果参数大于3【decorator为方法装饰器】 直接执行 decorator(target, key, targetinfo)
        // 如果参数等于3 【decorator为方法参数装饰器或者属性装饰器】 直接执行decorator(target, key)
        // targetinfo最终为各个装饰器执行后的返回值,但如果没有返回值,直接返回第S100行的targetinfo
        targetinfo = (argsnum < 3 ? decorator(targetinfo) : argsnum > 3 ?
          decorator(target, key, targetinfo) : decorator(target, key)) || targetinfo;
        console.log("targetinforesult:", targetinfo)
      }
    }
  return argsnum > 3 && targetinfo && Object.defineProperty(target, key, targetinfo), targetinfo;
}
// 底层 JS 组合装饰器和目标类 __decorate 函数结束

// 2.装饰器类
function ClassFunctionExtends (mytargetClass) {
  console.log("mytargetClass", mytargetClass);
  var SonClass = /** @class */ (function (_super) {
    __extends(SonClass, _super);
    function SonClass () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var _this = _super.call(this, args) || this;
      console.log("SonClass执行结束");
      return _this;
    }
    SonClass.prototype.commonMethod = function () {
      //console.log("this:", this)
      console.log("name:", this.name);
    };
    return SonClass;
  }(mytargetClass));
  return SonClass;
}

// 目标类
var Test = /** @class */ (function () {
  // 1.先执行原来构造函数
  function Test (name) {
    this.name = name;
    console.log("执行");
    //console.log("beforendame:", this.name)// lisi
  }
  Test.prototype.eat = function () {
    console.log(this.name, "吃饭");
  };
  Test = __decorate([
    ClassFunctionExtends
  ], Test);
  return Test;
}());

// 4.测试
var test = new Test("ok");
// let SonClass = twoDecorator<typeof Test>(Test)
//let SonClass = twoDecorator(Test)
//let SonClassObj=new SonClass("wangwu");
```

## 【泛型工厂类匿名类+继承装饰器】匿名类在装饰器中的实现

```js
function ClassFunctionExtends
  <T extends { new(...args: any[]): any }>
  (mytargetClass: T) {
  console.log("mytargetClass", mytargetClass);
  return class extends mytargetClass {
    constructor(...args: any[]) {
      super(args);
      console.log("SonClass执行结束");
    }
    commonMethod() {
      //console.log("this:", this)
      console.log("name:", this.name)
    }
  }
}
@ClassFunctionExtends
class Test {
  name!: string;
  age!: number
  // 1.先执行原来构造函数
  constructor(name: string) {
    this.name = name;
    console.log("执行");
    //console.log("beforendame:", this.name)// lisi
  }
  eat() {
    console.log(this.name, "吃饭");
  }
}
```

## 【方法装饰器】 拦截器意义，如何实现前置丶后置拦截器功能？【真实应用场景】

1.  方法装饰器的实现
2.  方法装饰器拦截器意义
3. 拦截器的前置、后置功能实现

**1.  方法装饰器的实现**

```js
// 1 不带参数的方法装饰器
function MyMethodDecorator(targetClassPrototype: any,key: string, methodDecri: PropertyDescriptor) {
  console.log("targetClassPrototype:", targetClassPrototype)
  console.log("key:", key);
}

class RoleService {
  public roleName: string = "管理员"
  constructor() {
  }

  @MyMethodDecorator
  DistribRoles() {// 分配角色
    console.log("分配角色.....");
  }
}
export { }
```

**2.  方法拦截器意义**

在方法装饰器中 拦截目标类的方法, 可以壮大或修改目标类的方法的功能

比如：增加一个日志信息，修改方法参数进行功能扩展处理。

**3.  拦截器的前置、后置功能实现**

```js
// 增强目标类的方法功能
class StringUtil {//工具类
  public static trimSpace(str: string): string {
    return str.replace(/\s+/g, "")
  }
}

class RoleService {
  public roleName: string = "管理员"
  constructor() {
  }

  @MethodInterceptor("DistribRoles方法")
  DistribRoles(userName: string, isValid: boolean) {// 分配角色
    console.log("分配角色.....");
  }
}

function MethodInterceptor(paramsValue: any) {
  console.log("方法装饰器....");
  return function (targetClassPrototype: any, methodName: any,
    methodDecri: PropertyDescriptor) {

    //targetMethodSave.value 表示原来目标类HttpClient的show()方法
    // 1.1 先保存目标类的方法到targetMethodSave
    console.log("进入方法装饰器：methodDecri:", methodDecri);
    let targetMethodSave = methodDecri.value;
    console.log("targetMethodSave:", targetMethodSave);

    // 1.2.让value函数建立新得函数对象空间
    //  value建立一个新的函数后,
    // RoleService对象调用DistribRoles;会执行value指向的新函数
    //  并不会执行原来RoleService目标类中DistribRoles方法
    //  这里建立的一个新函数
    methodDecri.value = function (...args: any[]) {
      console.log("this:", this);

      // 迭代所有参数
      args = args.map((arg) => {
        if (typeof arg === "string") {
          return StringUtil.trimSpace(arg);
        }
        return arg;
      })
      console.log(args)

      // 1.4.总结:这是一种典型的用方法装饰器扩大原来方法功能的案例

      // 1.5 但如果增强原来方法功能后,还想继续执行原来RoleService类中DistribRoles方法
      // 使用apply执行targetMethodSave原来函数
      targetMethodSave.apply(this, args)
    }
    //  方法执行之后，继续执行后续代码
    console.log("methodDecri.value:");
  }
}
```

## 【方法装饰器底层源码】逐行深剖底层 JS 源码

```js
"use strict";
// 1. 底层JS 组合装饰器和目标类 __decorate函数
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
  // argsnum 参数个数
  var argsnum = arguments.length;
  // targetinfo 被装饰器修饰的目标【类或属性或方法或方法参数，本案例为类】
  // argsnum=2 装饰器修饰的是类或者构造器参数，targetinfo=target[类名]
  // argsnum=4 装饰器修饰的是方法【第四个参数desc等于null] targetinfo=该方法的数据属性【desc = Object.getOwnPropertyDescriptor(target, key) 】
  // argsnum=3 装饰器修饰的是方法参数或者属性,targetinfo=undefined
  var targetinfo = argsnum < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;//S100
  // decorator保存装饰器数组元素
  var decorator;
  // 元数据信息,支持reflect-metadata元数据
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {
    targetinfo = Reflect.decorate(decorators, target, key, desc);
  } else
    //  装饰器循环,倒着循环,说明同一个目标上有多个装饰器，执行顺序是倒着执行
    for (var i = decorators.length - 1; i >= 0; i--) {
      if (decorator = decorators[i]) {
        // 如果参数小于3【decorator为类装饰器或者构造器参数装饰器】执行decorator(targetinfo)直接执行decorator装饰器，并传递目标targetinfo，这里是类
        // 如果参数大于3【decorator为方法装饰器】 直接执行 decorator(target, key, targetinfo) 
        // 如果参数等于3 【decorator为方法参数装饰器或者属性装饰器】 直接执行decorator(target, key)
        // targetinfo最终为各个装饰器执行后的返回值,但如果没有返回值,直接返回第S100行的targetinfo
        targetinfo = (argsnum < 3 ? decorator(targetinfo) : argsnum > 3 ?
          decorator(target, key, targetinfo) : decorator(target, key)) || targetinfo;
        console.log("targetinforesult:", targetinfo)
      }
    }
  return argsnum > 3 && targetinfo && Object.defineProperty(target, key, targetinfo), targetinfo;
}
Object.defineProperty(exports, "__esModule", { value: true });
// 底层JS 组合装饰器和目标类 __decorate函数结束

// 2. 工具类
var StringUtil = /** @class */ (function () {
  function StringUtil () {
  }
  StringUtil.trimSpace = function (str) {
    return str.replace(/\s+/g, "");
  };
  return StringUtil;
}());

// 目标类
var RoleService = /** @class */ (function () {
  function RoleService () {
    this.roleName = "管理员";
  }
  RoleService.prototype.DistribRoles = function (userName, isValid) {
    console.log("分配角色.....");
  };
  __decorate([
    MethodInterceptor("DistribRoles方法")
  ], RoleService.prototype, "DistribRoles", null);
  return RoleService;
}());

// 3. 装饰器方法
function MethodInterceptor (paramsValue) {
  console.log("方法装饰器....");
  return function (targetClassPrototype, methodName, methodDecri) {
    //targetMethodSave.value 表示原来目标类HttpClient的show()方法
    // 1.1 先保存目标类的方法到targetMethodSave
    console.log("进入方法装饰器：methodDecri:", methodDecri);
    var targetMethodSave = methodDecri.value;
    console.log("targetMethodSave:", targetMethodSave);
    // 1.2.让value函数建立新得函数对象空间 
    //  value建立一个新的函数后,
    // RoleService对象调用DistribRoles;会执行value指向的新函数
    //  并不会执行原来RoleService目标类中DistribRoles方法
    //  这里建立的一个新函数就和后端 Java的spring AOP中的方法拦截器思想就完全一样
    methodDecri.value = function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      console.log("this:", this);
      // 迭代所有参数
      args = args.map(function (arg) {
        if (typeof arg === "string") {
          return StringUtil.trimSpace(arg);
        }
        return arg;
      });
      console.log(args);
      // 1.4.总结:这是一种典型的用方法装饰器扩大原来方法功能的案例
      // 1.5 但如果增强原来方法功能后,还想继续执行原来RoleService类中DistribRoles方法
      // 使用apply执行targetMethodSave原来函数
      targetMethodSave.apply(this, args);
    };
    //  方法执行之后，继续执行后续代码
    console.log("methodDecri.value:");
  };
}
```

## 【方法装饰器底层源码 关联的 BUG 解决】方法拦截功能功能为什么会失效？

1. 测试删除__decorate方法最后一句代码 【Object.defineProperty(target, key, targetinfo)  】结果

2. 增加 Object.defineProperty(target, key, targetinfo) 代码的意义

```js
"use strict";
// __decorate方法最后一句代码
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
  // argsnum 参数个数
  var argsnum = arguments.length;
  // targetinfo 被装饰器修饰的目标【类或属性或方法或方法参数，本案例为类】
  // argsnum=2 装饰器修饰的是类或者构造器参数，targetinfo=target[类名]
  // argsnum=4 装饰器修饰的是方法【第四个参数desc等于null] targetinfo=该方法的数据属性【desc = Object.getOwnPropertyDescriptor(target, key) 】
  // argsnum=3 装饰器修饰的是方法参数或者属性,targetinfo=undefined
  var targetinfo = argsnum < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;//S100
  // decorator保存装饰器数组元素
  var decorator;
  // 元数据信息,支持reflect-metadata元数据
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {
    targetinfo = Reflect.decorate(decorators, target, key, desc);
  } else
    //  装饰器循环,倒着循环,说明同一个目标上有多个装饰器，执行顺序是倒着执行
    for (var i = decorators.length - 1; i >= 0; i--) {
      if (decorator = decorators[i]) {
        // 如果参数小于3【decorator为类装饰器或者构造器参数装饰器】执行decorator(targetinfo)直接执行decorator装饰器，并传递目标targetinfo，这里是类
        // 如果参数大于3【decorator为方法装饰器】 直接执行 decorator(target, key, targetinfo) 
        // 如果参数等于3 【decorator为方法参数装饰器或者属性装饰器】 直接执行decorator(target, key)
        // targetinfo最终为各个装饰器执行后的返回值,但如果没有返回值,直接返回第S100行的targetinfo
        targetinfo = (argsnum < 3 ? decorator(targetinfo) : argsnum > 3 ?
          decorator(target, key, targetinfo) : decorator(target, key)) || targetinfo;
        // 增加一句
        console.log("targetinforesult:", targetinfo)
      }
    }
  return argsnum > 3 && targetinfo && Object.defineProperty(target, key, targetinfo), targetinfo;
}
```

## 【属性装饰器】属性装饰器应用——顾客等级说明实现

```js
// 属性装饰器【这里先学会使用，后面实战再深入】
function loginProperty(attrValue: any) {
  return function (targetclassPrototype: object, attrname: string | symbol) {
    console.log("targetclassPrototype：", targetclassPrototype);
    console.log("attrname：", attrname);
    (targetclassPrototype.constructor as any).custLevelDescri = function () {
      console.log("消费5000元升级为贵宾");
      console.log("消费10000元升级为贵宾,赠送微波炉一个");
    }
  }
}

// 顾客目标类
class CustomerService {
  public custname: string = "王五"
  @loginProperty("顾客登记")
  public degree!: string
  constructor() {
  }

  show() {
    console.log("顾客名:", this.custname)
  }
}

(CustomerService as any).custLevelDescri()
```

## 【属性装饰器底层源码】   逐行解析底层JS源码

```js
// 1. 底层JS 组合装饰器和目标类 __decorate 函数
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
  // argsnum 参数个数
  var argsnum = arguments.length;
  // targetinfo 被装饰器修饰的目标【类或属性或方法或方法参数，本案例为类】
  // argsnum=2 装饰器修饰的是类或者构造器参数，targetinfo=target[类名]
  // argsnum=4 装饰器修饰的是方法【第四个参数desc等于null] targetinfo=该方法的数据属性【desc = Object.getOwnPropertyDescriptor(target, key) 】
  // argsnum=3 装饰器修饰的是方法参数或者属性,targetinfo=undefined
  var targetinfo = argsnum < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;//S100
  // decorator保存装饰器数组元素
  var decorator;
  // 元数据信息,支持reflect-metadata元数据
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {
    targetinfo = Reflect.decorate(decorators, target, key, desc);
  } else
    //  装饰器循环,倒着循环,说明同一个目标上有多个装饰器，执行顺序是倒着执行
    for (var i = decorators.length - 1; i >= 0; i--) {
      if (decorator = decorators[i]) {
        // 如果参数小于3【decorator为类装饰器或者构造器参数装饰器】执行decorator(targetinfo)直接执行decorator装饰器，并传递目标targetinfo，这里是类
        // 如果参数大于3【decorator为方法装饰器】 直接执行 decorator(target, key, targetinfo) 
        // 如果参数等于3 【decorator为方法参数装饰器或者属性装饰器】 直接执行decorator(target, key)
        // targetinfo最终为各个装饰器执行后的返回值,但如果没有返回值,直接返回第S100行的targetinfo
        targetinfo = (argsnum < 3 ? decorator(targetinfo) : argsnum > 3 ?
          decorator(target, key, targetinfo) : decorator(target, key)) || targetinfo;
        console.log("targetinforesult:", targetinfo)
      }
    }
  return argsnum > 3 && targetinfo && Object.defineProperty(target, key, targetinfo), targetinfo;
}
// 底层 JS 组合装饰器和目标类 __decorate 函数结束

// 2. 属性装饰器
function loginProperty(attrValue) {
    return function (targetclassPrototype, attrname) {
        console.log("targetclassPrototype：", targetclassPrototype);
        console.log("attrname：", attrname);
        targetclassPrototype.constructor.custLevelDescri = function () {
            console.log("消费5000元升级为贵宾");
            console.log("消费10000元升级为贵宾,赠送微波炉一个");
        };
    };
}

// 3.目标类
var CustomerService = /** @class */ (function () {
    function CustomerService() {
        this.custname = "王五";
    }
    CustomerService.prototype.show = function () {
        console.log("顾客名:", this.custname);
    };
    __decorate([
        loginProperty("顾客登记")
    ], CustomerService.prototype, "degree");
    return CustomerService;
}());
CustomerService.custLevelDescri();
```

## 【属性丶类丶方法装饰器综合应用】依赖注入+请求方法，控制器初步实现

```js
//  Inject 依赖注入装饰器【这里先学会属性、类装饰器组合 连起来即可，为后面深入铺点基础，暂时不讲解依赖注入，对于依赖注入的好处，什么是 Controller, Service 层，后面实战再深入】

// 1 集合类
class Collection<T = any> {
  static collection: Collection = new Collection();

  private constructor() { }

  private containerMap = new Map<string | symbol, any>();

  public set(id: string | symbol, value: T): void {
    this.containerMap.set(id, value);
  }

  public get(id: string | symbol): T {
    return this.containerMap.get(id);
  }

  public has(id: string | symbol): Boolean {
    return this.containerMap.has(id);
  }
}
export default Collection.collection;

// 2 编写业务类
export class UserService {
  pname: string = "人民"
  public login() {
    console.log(this.pname + "登录....");
  }
}

//  3 编写类【控制器类———这个环节为初步实现，后面实战再扩充】
import { Inject } from './injectdecortator'
import { PeopleService } from './UserService'
import CollectionInstance from './Collection'
import ControllerDecorator from './ControllerDecorator'
import MethodDecorator from './methoddecorator'
import { Inject } from './injectdecortator'
import { UserService } from './UserService'
import CollectionInstance from './Collection'
import Controller from './ControllerDecorator'
import { RequestMethodDecorator } from './methoddecorator'
// 装饰器执行顺序： 1.属性装饰器==>2.方法参数装饰器==>3.方法装饰器===>4.类装饰器
@Controller("/")
class UserController {

  @Inject("userService")
  private userService?: UserService

  @RequestMethodDecorator("/login")
  public login(): void {
    //let peopleServiceInstace = CollectionInstance.get("userService");
    //peopleServiceInstace.login();
  }
}
//let controller = new Controller();
//controller.login();
export { }

// 4. 编写属性装饰器 【依赖注入属性装饰器———这个环节为初步实现，后面实战再深入】
//  安装元数据的第三方包 [yarn add reflect-metadata -S]
//  使用元数据装饰器需要安装元数据的第三方包【reflect-metadata】，这里先提前用下，后面会详解
// 元数据--为了帮助类，方法，属性实现一定的功能，而附加在其上的一些数据
// 分类: 自定义的元数据  内置元数据
import 'reflect-metadata'
import CollectionInstance from './Collection'
type MyPropertyDecorator = (target: Object, propertyKey: string | symbol) => void;
export function Inject(injectid?: string): MyPropertyDecorator {
  return (targetClassPrototype, propertyKey) => {

    console.log("进入注入属性装饰器...Inject....")
    console.log("target:", targetClassPrototype);
    console.log("propertyKey:", propertyKey)
    console.log("依赖注入的id为:", injectid);

    // 重要
    const InjectServiceClass = Reflect.getMetadata("design:type", targetClassPrototype, propertyKey);
    CollectionInstance.set("userService", new InjectServiceClass())

    console.log("InjectServiceClass.prototype:", InjectServiceClass.prototype)
  }
}

// 5 编写方法装饰器【请求方法装饰器———这个环节为初步实现，后面实战再深入】
import 'reflect-metadata'
export default function get(path: string): MethodDecorator {
  return function (classTargetPrototype, methodname, dataprops) {
    console.log("进入到方法饰器", "path:", path);
    Reflect.defineMetadata('path', path, classTargetPrototype, methodname)
  }
}


// 6 编写类装饰器【控制器装饰器——这个环节为初步实现，后面实战再深入】
import 'reflect-metadata'
export default function ControllerDecorator<T extends { new(...args: any): any }>
  (targetClass: T) {
  console.log("进入到类控制器装饰器");
  Object.keys(targetClass.prototype).forEach((methodname) => {
    let path = Reflect.getMetadata("path", targetClass.prototype, methodname)
    console.log("path:", path);
  })
}

export { }
```

## 【参数装饰器】参数装饰器实现

```js
function UrlParam(params: any) {
  return function paramDecorator(targetClassPrototype: any,
    methodname: string, paramindex: number) {
    console.log("targetClassPrototype:", targetClassPrototype)
    console.log("methodname:", methodname);
    console.log("paramindex:", paramindex);
    targetClassPrototype.info = params
  }
}
class People {
  eat(@UrlParam("地址信息") address: string, who: string) {
    console.log("address:", address);
  }
}
```

## 【参数装饰器底层源码】  逐行解析底层 JS 源码

```js
"use strict";
// 1. 底层JS 组合装饰器和目标类 __decorate函数
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
  // argsnum 参数个数
  var argsnum = arguments.length;
  // targetinfo 被装饰器修饰的目标【类或属性或方法或方法参数，本案例为类】
  // argsnum=2 装饰器修饰的是类或者构造器参数，targetinfo=target[类名]
  // argsnum=4 装饰器修饰的是方法【第四个参数desc等于null] targetinfo=该方法的数据属性【desc = Object.getOwnPropertyDescriptor(target, key) 】
  // argsnum=3 装饰器修饰的是方法参数或者属性,targetinfo=undefined
  var targetinfo = argsnum < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;//S100
  // decorator保存装饰器数组元素
  var decorator;
  // 元数据信息,支持reflect-metadata元数据
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {
    targetinfo = Reflect.decorate(decorators, target, key, desc);
  } else
    //  装饰器循环,倒着循环,说明同一个目标上有多个装饰器，执行顺序是倒着执行
    for (var i = decorators.length - 1; i >= 0; i--) {
      if (decorator = decorators[i]) {
        // 如果参数小于3【decorator为类装饰器或者构造器参数装饰器】执行decorator(targetinfo)直接执行decorator装饰器，并传递目标targetinfo，这里是类
        // 如果参数大于3【decorator为方法装饰器】 直接执行 decorator(target, key, targetinfo) 
        // 如果参数等于3 【decorator为方法参数装饰器或者属性装饰器】 直接执行decorator(target, key)
        // targetinfo最终为各个装饰器执行后的返回值,但如果没有返回值,直接返回第S100行的targetinfo
        targetinfo = (argsnum < 3 ? decorator(targetinfo) : argsnum > 3 ?
          decorator(target, key, targetinfo) : decorator(target, key)) || targetinfo;
        console.log("targetinforesult:", targetinfo)
      }
    }
  return argsnum > 3 && targetinfo && Object.defineProperty(target, key, targetinfo), targetinfo;
}
// 底层JS 组合装饰器和目标类 __decorate函数结束


// Object.defineProperty(exports, "__esModule", { value: true });
// 2 带参数的装饰器
function UrlParam(params) {
    return function paramDecorator(targetClassPrototype, methodname, paramindex) {
        console.log("targetClassPrototype:", targetClassPrototype);
        console.log("methodname:", methodname);
        console.log("paramindex:", paramindex);
        targetClassPrototype.info = params;
    };
}

// 3 封装带参数装饰器
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var People = /** @class */ (function () {
    function People() {
    }
    People.prototype.eat = function (address, who) {
        console.log("address:", address);
    };
    __decorate([
        __param(0, UrlParam("地址信息"))
    ], People.prototype, "eat", null);
    return People;
}());
```

## 【构造器参数装饰器】构造器参数装饰器注入实现

1. 先安装 reflect-metadata 第三方包
2. UserController 控制器类实现
3. UserService 业务类实现
4. 保存对象的集合类实现 【单件设计模式】
5. 构造参数装饰器实现

```js
// 1 先安装 cnpm i reflect-metadata -D

// 2 UserController.ts
import { InjectContructor } from './InjectContructorDecorator'
import UserService from './UserService'
import collectionInstance from './Collection'
class UserController {

   constructor(@InjectContructor("userService")
         private userService: UserService, private count: string) { 

  }

  public login() {
    let peopleServiceInstace = collectionInstance.get("userService");
    peopleServiceInstace.login();
  }
}
let controller = new UserController();
controller.login();

// 3 构造参数装饰器
import 'reflect-metadata'
import collectionInstance from './Collection'
type MyParameterDecorator = (target: Object,
  paramname: string | symbol, parameterIndex: number) => void;
export function InjectContructor(injectid?: string): MyParameterDecorator {
  return (target, paramname, index) => {
     // 获取 target 目标类上构造函数所有参数类型
    const InjectConstructorClass = Reflect.getMetadata("design:paramtypes", target);
    console.log("InjectConstructorClass:", InjectConstructorClass)
    let  InjectConstructorClassobj = new InjectConstructorClass[index]()
    collectionInstance.set(injectid, InjectConstructorClassobj);
  }
}

// 4 UserService业务类
export class UserService {
  pname: string = "人民"
  public login() {
    console.log(this.pname + "登录....");
  }
}

// 5 保存对象的集合类【单件设计模式】
export class Collection<T = any> {
  static collection: Collection = new Collection();
 
  private constructor() {
    console.log("构造。。。。");
  }

  public static test() {
    console.log("test....");
  }
  private containerMap = new Map<string | symbol, any>();

  public set(id: string | symbol, value: T): void {
    this.containerMap.set(id, value);
  }

  public get(id: string | symbol): T {
    return this.containerMap.get(id);
  }

  public has(id: string | symbol): Boolean {
    return this.containerMap.has(id);
  }
}
export default Collection.collection;


export { }
```


## 【多个装饰器组合执行】 类、属性、方法 、参数装饰器组合+执行顺序

1. 类、属性、方法 、参数装饰器组合案例实现
2. 执行顺序
3. 底层源码

**1.  类丶属性丶方法 丶参数装饰器组合案例实现   2.  执行顺序**
```js
// 1.  类丶属性丶方法 丶参数装饰器组合案例实现   2.  执行顺序
function firstMethodDecorator(targetClassPrototype: any,
  methodname: string) {
  console.log("=============执行第一个方法装饰器==============")
  console.log("类名:", targetClassPrototype)//  类原型对象变量   URLInfo { show: [Function] }
  console.log("方法名:", methodname);//key
}


function secondMethodDecorator(params: string) {
  return function (targetClassPrototype: any, methodname: string) {
    console.log("=============执行第二个方法装饰器==============")
    console.log("类名:", targetClassPrototype)//  类原型对象变量   URLInfo { show: [Function] }
    console.log("方法名:", methodname);//key
  }
}

function paramDecorator(targetClassPrototype: any, paramname: string, paramindex: number) {
  console.log("=============执行参数装饰器==============")
  console.log("targetClassPrototype:", targetClassPrototype);
  console.log("参数名:", paramname);
  console.log("参数索引:", paramindex);
}


function UrlPropDecorator(targetClassPrototype: any, attrname: any) {

  console.log("=============执行属性装饰器==============")
  console.log("targetClassPrototype:", targetClassPrototype);
  console.log("属性名:", attrname);
}


function URLInfoDecorator(targetClassPrototype: any) {
  console.log("==========类装饰器============")
  console.log("targetClassPrototype:", targetClassPrototype);
}

function constructorDecorator(params: any) {
  return function (targetClassPrototype: any, paramname: string, paramindex: number) {
    console.log("==========构造器参数装饰器============")
    console.log("构造器参数装饰器", targetClassPrototype);
    console.log("构造器参数名为:", paramname);
    console.log("构造器参数索引位置:", paramindex);
  }
}

@URLInfoDecorator
class URLInfo {
  constructor(@constructorDecorator("url") public uri: string) {

  }

  @UrlPropDecorator
  public url: string = "https://www.imooc.com"


  @firstMethodDecorator
  methodOne(@paramDecorator data: string) {
    console.log("this:", this);
    console.log("目标类:", this.uri)
  }

  @secondMethodDecorator("yes")
  methodTwo(@paramDecorator address: string) {
    console.log(address)
  }
}
export { }
```

**3. 底层源码**

```js
// 1. 底层JS 组合装饰器和目标类 __decorate函数
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
  // argsnum 参数个数
  var argsnum = arguments.length;
  // targetinfo 被装饰器修饰的目标【类或属性或方法或方法参数，本案例为类】
  // argsnum=2 装饰器修饰的是类或者构造器参数，targetinfo=target[类名]
  // argsnum=4 装饰器修饰的是方法【第四个参数desc等于null] targetinfo=该方法的数据属性【desc = Object.getOwnPropertyDescriptor(target, key) 】
  // argsnum=3 装饰器修饰的是方法参数或者属性,targetinfo=undefined
  var targetinfo = argsnum < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;//S100
  // decorator保存装饰器数组元素
  var decorator;
  // 元数据信息,支持reflect-metadata元数据
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {
    targetinfo = Reflect.decorate(decorators, target, key, desc);
  } else
    //  装饰器循环,倒着循环,说明同一个目标上有多个装饰器，执行顺序是倒着执行
    for (var i = decorators.length - 1; i >= 0; i--) {
      if (decorator = decorators[i]) {
        // 如果参数小于3【decorator为类装饰器或者构造器参数装饰器】执行decorator(targetinfo)直接执行decorator装饰器，并传递目标targetinfo，这里是类
        // 如果参数大于3【decorator为方法装饰器】 直接执行 decorator(target, key, targetinfo) 
        // 如果参数等于3 【decorator为方法参数装饰器或者属性装饰器】 直接执行decorator(target, key)
        // targetinfo最终为各个装饰器执行后的返回值,但如果没有返回值,直接返回第S100行的targetinfo
        targetinfo = (argsnum < 3 ? decorator(targetinfo) : argsnum > 3 ?
          decorator(target, key, targetinfo) : decorator(target, key)) || targetinfo;
        console.log("targetinforesult:", targetinfo)
      }
    }
  return argsnum > 3 && targetinfo && Object.defineProperty(target, key, targetinfo), targetinfo;
}
// 底层JS 组合装饰器和目标类 __decorate函数结束

function firstMethodDecorator(targetClassPrototype, methodname) {
    console.log("=============执行第一个方法装饰器==============");
    console.log("类名:", targetClassPrototype); //  类原型对象变量   URLInfo { show: [Function] }
    console.log("方法名:", methodname); //key
}
function secondMethodDecorator(params) {
    return function (targetClassPrototype, methodname) {
        console.log("=============执行第二个方法装饰器==============");
        console.log("类名:", targetClassPrototype); //  类原型对象变量   URLInfo { show: [Function] }
        console.log("方法名:", methodname); //key
    };
}
function paramDecorator(targetClassPrototype, paramname, paramindex) {
    console.log("=============执行参数装饰器==============");
    console.log("targetClassPrototype:", targetClassPrototype);
    console.log("参数名:", paramname);
    console.log("参数索引:", paramindex);
}
function UrlPropDecorator(targetClassPrototype, attrname) {
    console.log("=============执行属性装饰器==============");
    console.log("targetClassPrototype:", targetClassPrototype);
    console.log("属性名:", attrname);
}
function URLInfoDecorator(targetClassPrototype) {
    console.log("==========类装饰器============");
    console.log("targetClassPrototype:", targetClassPrototype);
}
function constructorDecorator(params) {
    return function (targetClassPrototype, paramname, paramindex) {
        console.log("==========构造器参数装饰器============");
        console.log("构造器参数装饰器", targetClassPrototype);
        console.log("构造器参数名为:", paramname);
        console.log("构造器参数索引位置:", paramindex);
    };
}
var URLInfo = /** @class */ (function () {
    function URLInfo(uri) {
        this.uri = uri;
        this.url = "https://www.imooc.com";
    }
    URLInfo.prototype.methodOne = function (data) {
        console.log("this:", this);
        console.log("目标类:", this.uri);
    };
    URLInfo.prototype.methodTwo = function (address) {
        console.log(address);
    };
    __decorate([
        UrlPropDecorator
    ], URLInfo.prototype, "url", void 0);
    __decorate([
        firstMethodDecorator,
        __param(0, paramDecorator)
    ], URLInfo.prototype, "methodOne", null);
    __decorate([
        secondMethodDecorator("yes"),
        __param(0, paramDecorator)
    ], URLInfo.prototype, "methodTwo", null);
    URLInfo = __decorate([
        URLInfoDecorator,
        __param(0, constructorDecorator("url"))
    ], URLInfo);
    return URLInfo;
}());

```

## 【元数据操作】 理解 reflect-metadata  元数据操作重载方法和其他方法

1. 元数据定义、作用
2. 对象和对象属性上使用元数据
3. 直接在类，方法上定义元数据
4. 直接在类属性上定义元数据
5. 在装饰器内部为类，方法，属性定义或者获取元数据
6. metakey 相同，是否会覆盖？

**1. 元数据定义、作用**

**1.1 什么是元数据**

元数据指附加在对象、类、方法、属性丶参数上的数据。

**1.2 元数据作用**

元数据用来帮助提供实现某种业务功能需要用到的数据。

**2.  对象和对象属性上使用元数据**

步骤： 1.  安装 reflect-metadata 第三方库包

```bash
cnpm i reflect-metadata -S
```

步骤2：代码：

```js
import 'reflect-metadata'
// 1. 对象
let obj = {
  username: "罗斯福",
  age: 23,
  info() {
    console.log("信息");
  }
}
// 2. 使用 Reflect.defineMetadata 定义元数据。

// 2.1  Reflect.defineMetadata 是一个重载的方法
//  定义格式
//  为类或者对象上定义元数据
 Reflect.defineMetadata(metakey,metavalue,targetClassOrObject)
//  为方法定义元数据
 Reflect.defineMetadata(metakey,metavalue,targetprototype,methodname)
//  为属性定义元数据
 Reflect.defineMetadata(metakey,metavalue,targetprototype,propkey)

// 说明：打开 d.ts 定义描述文件说明：Reflect 是命名空间，defineMetadata 是命名空间中的一个方法。

//  2.2 在对象上定义元数据
Reflect.defineMetadata('firstdescribe', '对象属性全部符合要求', obj);
Reflect.defineMetadata('seconddescribe', '对象不可删除', obj);

//  2.3 获取obj上metakey为 firstdescribe 的值
console.log(Reflect.getMetadata('firstdescribe', obj))// 输出对象属性全部符合要求

//  2.4 获取obj上metakey不存在的值
console.log(Reflect.getMetadata('threedescribe', obj))// 输出undefined

//  3  使用 Reflect.defineMetadata 在对象属性上定义元数据。
//  3.1 在对象属性上定义和获取元数据
Reflect.defineMetadata('usernamemetakey', '用户名合法', obj,"username");
Reflect.getMetadata('usernamemetakey', obj, "username"));// 输出用户名合法

//  3.2 使用 Reflect.hasMetadata 查看对象或对象属性上是否存在某个元数据
if (Reflect.hasMetadata('describe', obj)) {
  console.log("obj存在describe元数据");
}

```

**3  直接在类，方法上定义元数据**

```js

// 1. 在类上定义元数据
@Reflect.metadata('decribe', '都是地球人')
class People {
  @Reflect.metadata("descible", "姓名不能包含非法汉字")
  username = "wangwu"
  @Reflect.metadata("importinfo", "去吃陶然居好吗")
  eat() {

  }
}
// 2
// 2.1 获取类上的元数据
console.log(Reflect.getMetadata('decribe', People));// 都是地球人

// 2.2 获取方法上的元数据 第二个参数是原型
console.log(Reflect.getMetadata('importinfo', People.prototype, 'eat'));//去吃陶然居好吗

// 2.3 判断People.prototype 原型上 eat 方法上是否存在importinfo元数据
if (Reflect.hasMetadata('importinfo', People.prototype, 'eat')) {
  console.log("hasMetadata=>People原型上存在eat方法的importinfo元数据");
}


// 3 定义子类
class ChinesePeople extends People {
  guoYear() {

  }
}

//  4 子类获取父类原型上的方法 ———— hasMetadata
if (Reflect.hasMetadata('importinfo', ChinesePeople.prototype, 'eat')) {
  console.log("hasMetadata=>ChinesePeople原型上通过继承也获取到了eat方法和eat方法的importinfo元数据");
}

//  5  获取自有元数据,但不能获取原型链上父类的元数据 ———— hasOwnMetadata
if (Reflect.hasOwnMetadata('importinfo', ChinesePeople.prototype, 'eat')) {
  console.log("hasOwnMetadata=>ChinesePeople原型上存在eat方法的importinfo元数据");
} else {
  console.log("hasOwnMetadata=>ChinesePeople原型上不存在eat方法的importinfo元数据");
}
```

**4  直接在类属性上定义元数据**

```js
import 'reflect-metadata'

// 为类定义元数据
@Reflect.metadata("info", "地球人")
class People {
  @Reflect.metadata('descible1', '居住地为主要城市')
  @Reflect.metadata('descible2', '上海')
  place: Array<string> = ["中国", "北京"]

  @Reflect.metadata('firstname', '第一个名字')
  @Reflect.metadata('lastname', '最后一个名字')
  getFullName(name: string, age: string): number {
    return 100
  }
}

// 获取元数据
console.log(Reflect.getMetadata('info', People));//地球人
console.log(Reflect.getMetadata("descible", People.prototype, 'place'));//rose
console.log(Reflect.getMetadata('firstname', People.prototype, 'getFullName'))//Jim
console.log(Reflect.getMetadata('lastname', People.prototype, 'getFullName'))//Jim
// [
//   'design:returntype',
//   'design:paramtypes',
//   'design:type',
//   'lastname',
//   'firstname'
// ]
// // 获取People.prototype 上getFullName方法的全部元数据Key组成的数组
//console.log(Reflect.getMetadataKeys(People.prototype, "getFullName"));
// Reflect.getMetadataKeys(People.prototype).forEach((item) => {
//   console.log("metadatakey:", item);
// })
// Reflect.getMetadataKeys(People.prototype, 'getFullName').forEach((metakey) => {
//   console.log("11metadatakey:", metakey);
//   console.log(Reflect.getMetadata(metakey, People.prototype, 'getFullName'));
// })

// 获取People类上place方法的全部元数据Key组成的数组
// 输出
// [
//   'design:type',
//   'descible1',
//   'descible2'
// ]
console.log(Reflect.getMetadataKeys(People.prototype, "place"));

Reflect.getMetadataKeys(People.prototype, 'place').forEach((metakey) => {
  console.log("属性metadatakey:", metakey);
  console.log(Reflect.getMetadata(metakey, People.prototype, 'place'));
})


class ChinesePeople extends People {
  @Reflect.metadata("descible", "姓名不能包含非法汉字")
  guoYear(args: string) {

  }
}
console.log("getMetadataKeys==>查看父类上的方法...");
console.log(Reflect.getMetadataKeys(ChinesePeople.prototype, 'getFullName'))//Jim
console.log("getOwnMetadataKeys不能查看父类上的方法...");
console.log(Reflect.getOwnMetadataKeys(ChinesePeople.prototype, 'getFullName'))//Jim

```

**5 在装饰器内部为类，方法，属性定义或者获取元数据**

方法装饰器中定义的元数据之后类装饰器获取方法上定义过的元数据

**6 metakey 相同，是否会覆盖？**

```js
import 'reflect-metadata'

// 直接为类或属性或方法定义元数据

// 为类定义元数据
@Reflect.metadata('decribe', '都是地球人')
class People {
  username = "wangwu"

  eat() {

  }
}

@Reflect.metadata('decribe', '木星和太阳')
class Customer {
  username = "wangwu"
  eat() {

  }
}


// 获取元数据
console.log(Reflect.getMetadata('decribe', People));// 都是地球人
```


##   [元数据]   3 个重要且特殊的内置元数据 key

主要理解以下三个类型元数据

**条件：** 在当前装饰器修饰前提下执行下面元数据 key

1. design:paramtypes  a. 构造器所有参数数据类型组成的数组   b. 类中方法全部参数的数据类型组成的数组

2. design:type   a. 获取类属性的数据类型  b. 获取类方法参数的数据类型

3. design:returntype   a. 获取类方法返回值的数据类型

```js
// 1. 构造器装饰器
import 'reflect-metadata'
import ContainerInstance from './container'
type MyParameterDecorator = (target: Object,
  paramname: string | symbol, parameterIndex: number) => void;

export function InjectContructor(injectid?: string): MyParameterDecorator {
  return (target, paramname, index) => {

    console.log(" 进入构造函数的参数装饰器....", target);
    console.log("获取类构造器参数类型组成的数组....")
    const constructorParamTypeArr = Reflect.getMetadata("design:paramtypes", target);
    console.log("design:paramtypes:", constructorParamTypeArr)

    let injectInstance = new constructorParamTypeArr[index]()
    ContainerInstance.set(injectid, injectInstance);
  }
}

// 2. 方法装饰器
type MethodDecorator = <T>(target: Object, propertyKey: string | symbol,
  descriptor: TypedPropertyDescriptor<T>) => TypedPropertyDescriptor<T> | void;

export function get(injectid?: string): MethodDecorator {
  return (targetprototype, methodname, descriptor) => {
    console.log(" 进入方法装饰器....", targetprototype);

    const methodParamTypeArr = Reflect.getMetadata("design:paramtypes", targetprototype, methodname);
    console.log("design:paramtypes:", methodParamTypeArr)

    const methodReturnTypeArr = Reflect.getMetadata("design:returntype", targetprototype, methodname);
    console.log("design:returntype:", methodReturnTypeArr)
  }
}

// 3. 属性装饰器
type MyPropertyDecorator = (target: any, propertyKey: string | symbol) => void;
import collection from './Collection'
export function InjectProperty(inject?: any): MyPropertyDecorator {

  return function (targetproperty, propertyKey) {

    console.log(" 进入属性参数装饰器....", targetproperty);

    console.log("获取类属性的数据类型");
    const propType = Reflect.getMetadata("design:type", targetproperty, propertyKey);
    console.log("design:type:", propType)
  }
}

// 4. 集合类
class Collection<T = any> {
  static collection: Collection = new Collection();
  private constructor() { }

  private containerMap = new Map<string | symbol, any>();

  public set(id: string | symbol, value: T): void {
    this.containerMap.set(id, value);
  }

  public get(id: string | symbol): T {
    return this.containerMap.get(id);
  }

  public has(id: string | symbol): Boolean {
    return this.containerMap.has(id);
  }
}
export default Collection.collection;

// 5 控制器类
import { UserService } from './UserService'
import collection from './Collection'
import InjectContructor from './InjectContructorDecorator'
import { get } from './MyMethodDecorator'
import { InjectProperty } from './MyPropertyDecorator'
class UserController {

  @InjectProperty("userService")
  private userService!: UserService
  constructor(@InjectContructor("userService") private peopleService?: UserService, count?: number) {

  }

  @get("/path")
  public login(username: string, pwd: number): number {
    let peopleServiceInstace = collection.get("userService");
    peopleServiceInstace.login();
    console.log("进入login方法...")
    return 3
  }
}
let controller = new UserController();
controller.login("wangwu", 23);
export { }

// 6 业务逻辑层类
export class UserService {
  pname: string = "人民"
  public login() {
    console.log(this.pname + "登录....");
  }
}

export { }
```

## 【仿 Nestjs 装饰器实战准备】多门语言都有的依赖注入有什么好处？

大大降低类和关联类的耦合度，课堂举例打印机模式讲解依赖注入的好处。

## 【仿 Nestjs 装饰器实战准备】 项目分层

环境安装: yarn add express  express-session  reflect-metadata -S

分为：

1. service 业务逻辑层
2. controller 层
3. 装饰器 decorator 层
4. 中间件 middleaware 层
5. 路由 router 层
6. collection集合层  【也是容器层】
7. util 层
8. 启动文件

## 【仿 Nestjs 装饰器实战】 依赖注入实现准备

**1. UserService 类**

```js

export default class UserService {
  Login(username: string, pwd: string, role: string) {
    console.log("进入service ...Login,username:", username)

    if (username === "admin" && pwd === "123" && role === "admin") {
      return true;
    } else {
      return false;
    }
  }
  register() {
    console.log("usersevice...register")
  }
}
```

**2. 控制器——UserController**

```js
import Autowired from '../decorator/autowireddecortator'
import UserService from '../service/UserService'
import CollectionInstance from '../collection/'
// 装饰器执行顺序： 1.属性装饰器==>2.方法参数装饰器==>3.方法装饰器===>4.类装饰器
class UserController {

  @Autowired("userService")//  修改Inject 为更专业的 Autowired 单词
  private userService!: UserService // 修改Inject 为更专业的 Autowired 单词


  public login(): void {
    // 增加....
  }
}
let controller = new UserController();
controller.login();
export { }
```

**3. 为控制器属性注入对象的注入装饰器——autowireddecortator.ts**

```js
import 'reflect-metadata'
import collectionInstance from '../collection'

type MyPropDecorator = (targetClassPrototype: any, propertyKey: string | symbol) => void
export default function Autowired(injectid: string): MyPropDecorator {
  return (targetClassPrototype, propertyKey) => {
    // PropClass=UserService类
    let PropClass = Reflect.getMetadata("design:type", targetClassPrototype, propertyKey)
    //  增加....
  }
}
```

## 【仿 Nestjs 装饰器实战】  依赖注入实现准备——优化存储

```js
import 'reflect-metadata'
import collectionInstance from '../collection'

type MyPropDecorator = (targetClassPrototype: any, propertyKey: string | symbol) => void
export default function Autowired(injectid: string): MyPropDecorator {
  return (targetClassPrototype, propertyKey) => {
    // PropClass=UserService类
    let PropClass = Reflect.getMetadata("design:type",
      targetClassPrototype, propertyKey)
    //  增加....
    let PropClassObj = new PropClass();
    //collectionInstance.set(propertyKey, PropClassObj);
    // 对比:Object.defineProperty
    // 好处:由于targetClassPrototype原型+propertyKey一起是绝对不会被覆盖的
    // 充分保证了数据属性中的value的对象的唯一性
    Reflect.defineProperty(targetClassPrototype, propertyKey,
      { value: PropClassObj })
  }
}
```

## 【仿 Nestjs 装饰器实战】 依赖注入实现和升级自动装配装饰器

```js
// 10-21 【仿 Nestjs 装饰器实战】 依赖注入实现和升级自动装配装饰器
//  实现步骤   1. 建立伪接口类 UserServiceInter
//            2. 修改UserService的名字为userServiceImpl类
//            3. 修改自动装配装饰器【Autowired】代码:见增加和修改部分
//          最后别忘了修改UserController中的login方法中的S100中的属性名为userServiceImpl
```

## 10-22 【仿 Nestjs 装饰器实战】 依赖注入实现引发的深度思考

1. 理解实战涉及到的主要专业术语
2. 依赖注入中的单件模式实现方式1

**1. 理解实战涉及到的主要专业术语** 【比较抽象，先初步理解，随代码讲解逐步加深理解】

**@Controller** 控制器装饰器【@Controller】 修饰的类，是用来支持页面的各种请求的类。

**@Service** 业务逻辑层类装饰器

**@Autowired** 自动装配，一般是帮助把外部其他数据注入【简单理解为赋值】给当前类属性或方法参数的装饰器，这些数据可以是string，number等基本数据类型，也可以是一个对象。

**dependencyid** [injectid]  依赖ID,一个唯一标识符变量， 作为@Autowired装饰器函数的实参，使用@Autowired 为 不同类属性，或方法参数注入数据时，**dependencyid** 用于区分这些不同的类。
 **singleton**   标注是否是单例注入的参数，可选。

**2. 依赖注入中的单件模式实现方式1**

```js
import 'reflect-metadata'
import collectionInstance from '../collection'

type MyPropDecorator = (targetClassPrototype: any, propertyKey: string | symbol) => void
/**
 *
 * @param dependencyid[injectid] 依赖id
 * @param singleton -判断是否是单件模式的对象
 * @returns
 */
export default function Autowired(dependencyid?: string, singleton?: boolean): MyPropDecorator {
  return (targetClassPrototype, propertyKey) => {
    // PropClass=UserServiceInter伪接口类
    let PropServiceClass: any = Reflect.getMetadata("design:type",
      targetClassPrototype, propertyKey)
    //  在10-12代码基础上增加【开始】....
    let ServiceImplClass: any = PropServiceClass.getServiceImplClass();
    let ServiceImplInstance// 对象
    if (singleton) {// 如果是单件模式的对象的注入方式
      ServiceImplInstance = ServiceImplClass.getInstance();
    } else {
      ServiceImplInstance = new ServiceImplClass();
    }
    //  在10-12代码基础上增加【结束】....
    //collectionInstance.set(propertyKey, PropClassObj);
    // 对比:Object.defineProperty
    // 好处:由于targetClassPrototype原型+propertyKey一起是绝对不会被覆盖的
    // 充分保证了数据属性中的value的对象的唯一性
    Reflect.defineProperty(targetClassPrototype, propertyKey,
      { value: ServiceImplInstance })// 修改为 PropServiceImplClassObj

  }
}
```

## 【仿 Nestjs 装饰器实战】 依赖注入实现引发的深度思考+代码持续升级优化

依赖注入中的单件模式实现方式2实现

**1. 单件装饰器实现**

```js
import 'reflect-metadata'
type MyPropDecorator = (targetClassPrototype: any, propertyKey: string | symbol) => void

export default function Singleton(isSingleton: boolean): MyPropDecorator {
  return (targetClassPrototype, propertyKey) => {
    let PropServiceClass: any = Reflect.getMetadata("design:type",
      targetClassPrototype, propertyKey).
    let ServiceImplClass: any = PropServiceClass.getServiceImplClass();
    let ServiceImplInstanceOrClass// 对象
    let metaSingleton = Reflect.getMetadata("singleton",
      targetClassPrototype, propertyKey)

    if (isSingleton) {//如果是单件模式
      if (!metaSingleton) {// 第一次进来执行
        Reflect.defineMetadata("singleton", isSingleton, targetClassPrototype, propertyKey)
        ServiceImplInstanceOrClass = ServiceImplClass.getInstance();//单件模式获取唯一的对象
      } else {// 第二次或以上次重复进来执行
        console.log("单件模式创建,使用了上一次的对象");
      }
    } else {//如果不是单件模式,每次都创建一个对象
      ServiceImplInstanceOrClass = ServiceImplClass;
    }
    // 保存对象或者类
    Reflect.defineMetadata("ServiceImplInstanceOrClass",
      ServiceImplInstanceOrClass, targetClassPrototype, propertyKey)

  }
}
```

**2. 自动装配装饰器实现**

```js
import 'reflect-metadata'
import collectionInstance from '../collection'

type MyPropDecorator = (targetClassPrototype: any, propertyKey: string | symbol) => void
/**
 * 
 * @param dependencyid[injectid] 依赖id
 * @param singleton -判断是否是单件模式的对象 
 * @returns 
 */
export default function Autowired(dependencyid?: string, singleton?: boolean): MyPropDecorator {
  return (targetClassPrototype, propertyKey) => {
    let ServiceImplInstance: any
    let ServiceImplInstanceOrClass = Reflect.getMetadata("ServiceImplInstanceOrClass", targetClassPrototype, propertyKey)
    let metaSingleton = Reflect.getMetadata("singleton",
      targetClassPrototype, propertyKey)
    if (metaSingleton) {//如果是单件模式
      console.log("我是Autowired装饰器,单件模式获取对象");
      ServiceImplInstance = ServiceImplInstanceOrClass
    } else {
      ServiceImplInstance = new ServiceImplInstanceOrClass();
    }
    Reflect.defineProperty(targetClassPrototype, propertyKey,
      { value: ServiceImplInstance })// 修改为 PropServiceImplClassObj

  }
}
```

## 【仿 Nestjs 装饰器实战】数据访问层和实体层封装

**1. DAO 层 UserDaoImpl 类实现**

```js
import userinfosfrmdb from '../entity/UserInfo'
export default class UserDaoImpl {

  public findUsrByUsm(username: string, pwd: string) {
    return userinfosfrmdb.find((useinfo) => { return username === useinfo.username && pwd === useinfo.password })
  }

}
```

**2. 实体 层 Userinfo 实体类实现**

```js
export interface Userinfo {
  username: string,
  password: string,
  phone: string,
  role: string
  mark: string
}

// 数据表链接和本课程无关,但会模拟数据表数据操作
// 模拟Userinfo数据
let userinfosdb: Array<Userinfo> =
  [{
    username: "admin",
    password: "123",
    phone: "1111",
    role: "admin",
    mark: "管理员"
  },
  {
    username: "lisi",
    password: "123",
    phone: "1111",
    role: "general",
    mark: "开发工程师"
  },
  {
    username: "liuwu",
    password: "123",
    phone: "1111",
    role: "manager",
    mark: "项目精力"
  },
  ]

export default userinfosdb
```

**3. 业务逻辑层 UserService 类修改**

```js
import UserDaoImpl from '../dao/UserDaoImpl'
import { Userinfo } from '../entity/UserInfo'
export class UserServiceImpl {

  userDaoImpl: UserDaoImpl = new UserDaoImpl();
  static userServiceImpl: UserServiceImpl
  static getInstance() {
    if (!this.userServiceImpl) {
      this.userServiceImpl = new UserServiceImpl();
    }
    return this.userServiceImpl
  }

  constructor() {
    console.log("UserServiceImpl构造器....");
  }

  Login(username: string, pwd: string): Userinfo {
    console.log("进入service ...Login,username:", username)
    let userinfodb = this.userDaoImpl.findUsrByUsm(username, pwd)
    return userinfodb || null
  }
  register() {
    console.log("我是usersevice...register")
  }
}
```

## 【仿 Nestjs 装饰器实战】控制器装饰器和请求方法装饰器实现

**1. 环境搭建**

**1.1 安装包**

```js
 1 yarn add express -S
 2 yarn add @types/express -D
 3 yarn add express-session -S
 5 yarn add reflect-metadata -S
 6 yarn add typescript  -D
 7 yarn add nodemon -D
```

**1.2 配置 package.json  脚本**

```js
  "scripts": {
    "app": "nodemon --watch src/ -e ts --exec ts-node ./src/expressapp.ts",
    "ctrl": "ts-node src/controller/HomeController.ts"
  }
```

**1.3 修改 tsconfig.json  脚本**

```js
  // "strict": true 屏蔽strict
   "experimentalDecorators": true, // 开启
   "emitDecoratorMetadata": true, // 开启
```

**2.  编写工具类**

```js
// SessionUtil.ts 工具类
import { Request } from 'express'
export function getSession(req: Request) {
  return (req as any).session
}
```

**3. Controller 装饰器实现**

```js
import 'reflect-metadata'
import { Request, Response } from 'express'
import { Autowired, Singleton, get, post, Controller } from '../decorator/'
import { UserServiceImpl, UserServiceInter } from '../service'
import CollectionInstance from '../collection/'
import { getSession } from '../util/SessionUtil';
import { Userinfo } from '../entity/UserInfo'
@Controller("/")
class UserController {

  @Autowired("userServiceImpl")//  修改Inject 为更专业的 Autowired 单词
  @Autowired("userServiceImpl")
  @Singleton(true)
  private userServiceImpl!: UserServiceInter // 修改Inject 为更专业的 Autowired 单词

  @get("/login")
  login(req: Request, res: Response): void {

    let htmlstr = `<div><form method="post" 
    action = "/loginprocess"><div>用户名: 
    <input type='text' name = 'username'/> </div><div>
     密码: <input type='password' name = 'pwd'/> </div>
     <div><input type="submit" value = "提交" /> </div>
     </form></div>`
    res.send(htmlstr);
  }


  @post("/loginprocess")
  loginprocess(req: Request, res: Response): void {

    console.log("loginprocess=this:", this);
    let session = getSession(req);

    let UserServiceImpl: UserServiceImpl =
      Reflect.getOwnPropertyDescriptor(UserController.prototype,
        "userServiceImpl").value//S100
    let userinfofrmdb: Userinfo = UserServiceImpl.Login(req.body.username, req.body.pwd)
    if (userinfofrmdb && userinfofrmdb.username)
      session.userinfofrmdb = userinfofrmdb
    // 基础复习：req.send只能发送一次,如果想发送多次,就必须使用res.write
    res.setHeader("Content-Type", "text/html;charset=UTF-8")
    let outputhtml = "";
    if (userinfofrmdb.role === "admin") {
      outputhtml += `<div>管理员:${userinfofrmdb.role}</div>`
      outputhtml += `<div><a href="/rights">进入管理员权限页面</a></div>`
    }
    res.write(outputhtml);
    res.write(`<div>登录成功,欢迎你:${userinfofrmdb.username}</div>`);
    res.write(`<div><a  href="/">进入首页</a></div>`);
    res.end();
  }
}

// let controller = new UserController();
// controller.test();
export { }
```

**4.   get 请求方法装饰器实现**

```js
// methoddecorator.ts文件
import 'reflect-metadata'

// 封装方法装饰器
export function get(path: string) {
  console.log("进入方法装饰器", " path为", path);
  return function (targetPrototype: any, methodname: string) {
    console.log("执行的类是:", targetPrototype, " 方法是:", methodname)
    Reflect.defineMetadata('path', path, targetPrototype, methodname)
  }
}
```

**5. Controller 装饰器实现**

```js
import { router } from '../util/router'

type MyClassDecorator = <T extends { new(...args: any): any }>
  (targetClass: T) => any
export function Controller(reqRootPath: string): MyClassDecorator {
  return function (targetClass): any {
    console.log("控制器装饰器执行...");
    for (let methodname in targetClass.prototype) {
      let routerpath = Reflect.getMetadata("path", targetClass.prototype, methodname)

      // 拿到装饰器对应的方法
      const targetMethodfunc = targetClass.prototype[methodname];
      // S100理解：当执行对应routerpath时，会自动执行targetMethodfunc方法
      if (routerpath) {
        router.get(routerpath, targetMethodfunc);// S100
      }
    }
  }
}
```

**6.  路由器提取**

```js
import { Router } from 'express'
export const router: Router = Router();
```

**7. 增加装饰器二次导出**

```js
export * from './autowireddecortator'
export * from './methoddecorator'
export * from './singletondecorator'
export * from './controllerdecorator'
```

**8 启动文件 app 实现**

```js
import 'reflect-metadata'
import express from 'express'
import session from 'express-session'
// 引入控制器ts文件,会自动执行HomeController文件中方法装饰器@get和类装饰器@Controller
// 因为装饰器在/router/controlldecorators 这个文件中,
// 这一执行直接导致router增加了路由完成，就是controlldecorators的第S100行代码的执行
import './controller/UserController'

// 然后在引入路由器
import { router } from './router'

//Express4.16+已经在express包中加入了bodyParser,可直接作为express的方法使用.
const app = express();//Creates an Express application.

// 设置session关联的cookie信息
app.use(session({
  secret: "cookeid12345",
  name: "cookieinfo",
  resave: false,
  saveUninitialized: true,
}))

//   Express4.16+后的 处理表单数据 url 集成到了express框架中
app.use(express.urlencoded({ extended: false }))////处理表单数据 url
app.use(router)//添加路由到express应用对象-app对象中

let server = app.listen(5002, function () {
  console.log('node服务器启动,端口5002') //服务启动完成,输出日志
})

```

## 【仿 Nestjs装饰器实战】多种请求方法装饰器实现

1. 升级方法装饰器
2. 修改控制器装饰器
3. 新建权限控制器类

**1.  升级方法装饰器**

```js
// methoddecorator.ts文件
import 'reflect-metadata'
import MethodType from '../util/MethodUtil';

// 封装方法装饰器
function reqMethodDecorator(methodType: MethodType) {
  return function (path: string) {
    return function (targetPrototype: any, methodname: string) {
      console.log("方法装饰器:执行的类是:", targetPrototype, " 方法是:", methodname)
      Reflect.defineMetadata('path', path, targetPrototype, methodname)
      Reflect.defineMetadata('methodtype', methodType, targetPrototype, methodname)
    }
  }
}

export const get = reqMethodDecorator("get")
export const post = reqMethodDecorator("post")
```

**2 修改控制器装饰器**

```js
// controllclassdecorators.ts
import 'reflect-metadata'
import { RequestHandler } from 'express'

import MethodType from '../util/MethodUtil'

// 路由导入
import { router } from '../router'

// 通过装饰器实现项目路由功能
// 类装饰器
export function Controller(): MyClassDecorator {

  return function (targetClass) {
    //return function <T>(targetClass: { new(...args: any[]): T }) {
    Object.keys(targetClass.prototype).forEach((methodnamekey) => {

      // 请求路径
      let routerpath = Reflect.getMetadata("path", targetClass.prototype, methodnamekey)
      let methodtype: MethodType = Reflect.getMetadata("methodtype",
        targetClass.prototype, methodnamekey)

      // 拿到装饰器对应的方法
      const targetMethodfunc = targetClass.prototype[methodnamekey];
      // S100理解：当执行对应routerpath时，会自动执行targetMethodfunc方法
      if (routerpath && methodtype) {
        router[methodtype](routerpath, targetMethodfunc);
      }
    })
  }
}
```

## 【仿 Nestjs装饰器实战】多页面请求+中间件装饰器

**1 新建权限控制器类**

```js
// controller目录增加 RightsController.ts文件
import { Request, Response } from 'express'
import { get, Controller } from '../decorator/index'

@Controller()
export default class RightsControllers {

  @get("/rightsmanager")
  rightsShow(req: Request, res: Response) {
    console.log("rightShow")
    res.setHeader('Content-Type', 'text/html; charset=utf-8');
    res.write("管理员权限页面");
    res.write("<a href='javascript:history.back()'>返回</a>")
    res.send();
  }
}
```

**2 在 UserController 类增加 index 函数**

```js
  @get('/')
  index(req: Request, res: Response): void {
    if (getSession(req).userinfofrmdb) {
      let htmlstr = `<div><a href='/searchFoodHistory' style='text-decoration:none;color:red'> 搜索美食历史信息 </a></div><div><a href = '/orderInfo'  style='text-decoration:none;color:red'> 订单信息 </a></div><div><a href="/loginout" style='text-decoration:none;color:red'>注销</a></div>`;
      res.send(htmlstr);
    } else {
      res.redirect("/login")
    }
  }
```

**3 增加中间件装饰器**

```js
// decorator 目录 / methoddecorator.ts 文件
import { RequestHandler } from 'express'
import 'reflect-metadata'
export function middleware(middleware: RequestHandler) {
  return function (targetPrototype: any, key: string) {
    Reflect.defineMetadata("middleawares", middleware, targetPrototype, key)
  }
}
```

**4 增加 FoodController 类**

```js
import { Request, Response } from 'express'
import {
  get, middleware, Controller
} from '../decorator';
import { isValidUser } from '../middleaware/middleawarefunc'
@Controller("/")
class FoodController {

  @get("/showFood")
  @middleware(isValidUser)
  showFood(req: Request, res: Response): void {
    res.setHeader("Content-Type", "text/html; charset=utf-8")
    res.write("大混沌");
    res.write("一锅炖")
    res.end();
  }
}
```

**5 增加中间件**

```js
import { Request, Response, NextFunction } from 'express'
import { getSession } from '../util/sessionUtil';

export const isValidUser = (req: Request, res: Response,
  next: NextFunction) => {
  console.log("执行isValidUser...")
  let session = getSession(req);
  if (session.userinfofrmdb && session.userinfofrmdb.mark === "noallowlogin") {
    res.setHeader("Content-Type", "text/html; charset=utf-8")
    res.write("您是被禁人士，被限制访问");
    res.end();
  } else {
    next();
  }
}
```

**6 修改 Controller 装饰器**

```js
import { router } from '../util/router'
import MethodType from '../util/methodtype'
import { RequestHandler } from 'express'
// 枚举

type MyClassDecorator = <T extends { new(...args: any): any }>
  (targetClass: T) => any
export function Controller(reqRootPath: string): MyClassDecorator {
  return function (targetClass): any {
    console.log("控制器装饰器执行...");
    for (let methodname in targetClass.prototype) {
      let routerpath = Reflect.getMetadata("path", targetClass.prototype, methodname)
      // 拿到装饰器对应的方法export const post = requestDecorator("post")
      let methodType: MethodType = Reflect.getMetadata("methodType", targetClass.prototype, methodname)
      const targetMethodfunc: RequestHandler = targetClass.prototype[methodname];
      // 获取中间件装饰器保存的中间件函数元数据
      let middleawre: RequestHandler = Reflect.getMetadata("middleawares",
      targetClass.prototype, methodname)

      // S100理解：当执行对应routerpath时，会自动执行targetMethodfunc方法
      if (routerpath && methodType) {
        if (middleawre) {
          router[methodType](routerpath, middleawre, targetMethodfunc)
        } else {
          router[methodType](routerpath, targetMethodfunc)
        }
      }
    }
  }
}
```

**7. 在启动文件中引入 RightsController 和 FoodController**

```js
import './controller/UserController'
import './controller/RightsController'
import './controller/FoodController'
```

## 【仿 Nestjs 装饰器实战】多个中间件装饰器实现

**1. 在中间件文件中增加两个测试中间件函数**

```js
// 测试中间件函数1
export const SecondMiddleAware = (req: Request, res: Response,
  next: NextFunction) => {
  console.log("第二个中间件")
  next();
}
```

**2 为 FoodController 增加第二个中间件装饰器修饰**

```js
import { Request, Response } from 'express'
import {
  get, middleware, Controller
} from '../decorator';
import { isValidUser, SecondMiddleAware } from '../middleaware/middleawarefunc'
@Controller("/")
class FoodController {

  @get("/showFood")
  @middleware(SecondMiddleAware)
  @middleware(isValidUser)
  showFood(req: Request, res: Response): void {
    res.setHeader("Content-Type", "text/html; charset=utf-8")
    res.write("大混沌");
    res.write("一锅炖")
    res.end();
  }
}
```

**3.  修改中间件装饰器**

```js
// decorator 目录 / methoddecorator.ts 文件
import { RequestHandler } from 'express'
import 'reflect-metadata'
export function middleware(middleware: RequestHandler) {
  return function (targetPrototype: any, methodname: string) {
    // 方法1
    // 第一次进来的中间件函数middleware
    // let middlewares = Reflect.getMetadata("middleawares", targetPrototype, methodname)
    // if (!middlewares) {// 第一次进来的中间件函数数组赋值为初始值
    //   middlewares = []
    // }
    // 方法2
    let middlewares = Reflect.getMetadata("middleawares", targetPrototype, methodname) || []
    middlewares.push(middleware)
    Reflect.defineMetadata("middleawares", middlewares,
      targetPrototype, methodname)
  }
}
```

**4.  修改控制器装饰器**

```js
import { router } from '../util/router'
import MethodType from '../util/methodtype'
import { RequestHandler } from 'express'
// 枚举

type MyClassDecorator = <T extends { new(...args: any): any }>
  (targetClass: T) => any
export function Controller(reqRootPath: string): MyClassDecorator {
  return function (targetClass): any {
    console.log("控制器装饰器执行...");
    for (let methodname in targetClass.prototype) {
      let routerpath = Reflect.getMetadata("path", targetClass.prototype, methodname)
      // 拿到装饰器对应的方法export const post = requestDecorator("post")
      let methodType: MethodType = Reflect.getMetadata("methodType", targetClass.prototype, methodname)
      const targetMethodfunc: RequestHandler = targetClass.prototype[methodname];
      // 获取中间件装饰器保存的中间件函数元数据

      let middleawres: RequestHandler[] = Reflect.getMetadata("middleawares",
        targetClass.prototype, methodname)

      // S100理解：当执行对应routerpath时，会自动执行targetMethodfunc方法
      if (routerpath && methodType) {
        if (middleawres) {
          router[methodType](routerpath, ...middleawres, targetMethodfunc)
        } else {
          router[methodType](routerpath, targetMethodfunc)
        }
      }
    }
  }
}
```

## 【仿 Nestjs装饰器实战】解析路由器和请求参数对象底层复杂泛型

```ts
// TODO
```

## 【仿 Nestjs装饰器实战后的深度思考题】控制器根路径实现优化依赖注入对象调用

**深度思考题**

我们知道在 HomeController 中 获取 userService 是按照下面第 S100 行代码这样获取的，但实际开发时我们希望看到更彻底的依赖注入,  如何不写 S100 行就能直接获取 userService 对象 ，用更简洁的方式来调用。

```js
loginprocess(req: Request, res: Response): void {

    console.log("loginprocess=this:", this);
    let session = getSession(req);
    let UserServiceImpl: UserServiceImpl =
  Reflect.getOwnPropertyDescriptor(UserController.prototype,"userServiceImpl").value  // S100
    let userinfofrmdb: Userinfo = UserServiceImpl.Login(req.body.username, req.body.pwd)

}
```

**作业：如果 控制器装饰器增加了根路径 比如： controller("/home")，那又该如何处理请求路径？**

```js
@Controller("/usermodule")
class UserController {

  //@Autowired("userServiceImpl")//  修改Inject 为更专业的 Autowired 单词
  @Autowired("userServiceImpl")
  @Singleton(true)
  private userServiceImpl!: UserServiceInter // 修改
  .....
}
```

